[
  {
    "name": "Volatility Window",
    "active": false,
    "nodes": [
      {
        "parameters": {
          "triggerTimes": {
            "item": [
              {
                "mode": "everyX",
                "value": 1,
                "unit": "minutes"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.cron",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "0ec07dd3-57be-4bee-a778-46f0f23cdf11",
        "name": "Cron"
      },
      {
        "parameters": {
          "method": "GET",
          "url": "http://bridge:3000/calendar-feed",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          260,
          0
        ],
        "id": "11111111-2222-4333-8444-555555555555",
        "name": "Fetch Calendar"
      },
      {
        "parameters": {
          "jsCode": "const preWindowMs = 7 * 60 * 1000;\nconst duringWindowMs = 4 * 60 * 1000;\nconst postWindowMs = 9 * 60 * 1000;\n\nconst nowMs = Date.now();\nconst nowUtc = new Date(nowMs).toISOString();\nconst staticData = $getWorkflowStaticData('global');\n\nconst log = (payload) => {\n  console.log(JSON.stringify({ workflow: 'volatility-state-mvp-cache', ...payload }));\n};\n\nconst resolvePhase = (eventMs, ts) => {\n  if (eventMs - preWindowMs <= ts && ts < eventMs) return 'pre_event';\n  if (eventMs <= ts && ts < eventMs + duringWindowMs) return 'during_event';\n  if (eventMs + duringWindowMs <= ts && ts < eventMs + postWindowMs) return 'post_event';\n  return 'none';\n};\n\nconst runStep = (stepName, handler) => {\n  try {\n    return handler();\n  } catch (error) {\n    log({\n      now_utc: nowUtc,\n      error: 'compute_step_failed',\n      failed_block: stepName,\n      error_message: error && error.message ? error.message : String(error)\n    });\n    throw error;\n  }\n};\n\nconst normalizedInput = runStep('NormalizeInput', () => {\n  const inputItems = $input.all();\n  const first = inputItems.length > 0 ? inputItems[0].json : null;\n  const payload = first && Array.isArray(first.items) ? first.items : [];\n  return { first, payload };\n});\n\nif (!Array.isArray(normalizedInput.payload) || normalizedInput.payload.length === 0) {\n  log({\n    now_utc: nowUtc,\n    error: 'calendar_payload_empty',\n    failed_block: 'NormalizeInput',\n    feed_source: normalizedInput.first && normalizedInput.first.source\n  });\n  return [];\n}\n\nconst candidates = runStep('BuildActiveCandidates', () => {\n  const highEvents = normalizedInput.payload\n    .filter((e) => e && e.impact === 'High' && typeof e.title === 'string' && typeof e.date === 'string')\n    .map((e) => {\n      const eventMs = Date.parse(e.date);\n      if (Number.isNaN(eventMs)) return null;\n      return { ...e, eventMs };\n    })\n    .filter(Boolean);\n\n  const activeEvents = highEvents\n    .map((e) => ({ event: e, phase: resolvePhase(e.eventMs, nowMs) }))\n    .filter((x) => x.phase !== 'none')\n    .sort((a, b) => Math.abs(a.event.eventMs - nowMs) - Math.abs(b.event.eventMs - nowMs));\n\n  return { highEvents, activeEvents };\n});\n\nconst phaseAndState = runStep('ResolvePhaseAndState', () => {\n  const primary = candidates.activeEvents.length > 0 ? candidates.activeEvents[0] : null;\n  const newState = primary ? 'RED' : 'GREEN';\n  const newPhase = primary ? primary.phase : 'none';\n  return { primary, newState, newPhase };\n});\n\nconst diffState = runStep('DiffWithPreviousState', () => {\n  const prevState = staticData.current_state ?? null;\n  const prevPhase = staticData.current_phase ?? null;\n  const firstRun = prevState === null;\n  const bootstrapKey = 'mvp_bootstrap_sent_v2';\n  const bootstrapSend = staticData[bootstrapKey] !== true;\n  const changed = firstRun || prevState !== phaseAndState.newState || prevPhase !== phaseAndState.newPhase || bootstrapSend;\n\n  staticData.current_state = phaseAndState.newState;\n  staticData.current_phase = phaseAndState.newPhase;\n  staticData[bootstrapKey] = true;\n\n  return {\n    prevState,\n    prevPhase,\n    changed\n  };\n});\n\nlog({\n  now_utc: nowUtc,\n  feed_source: normalizedInput.first && normalizedInput.first.source,\n  prev_state: diffState.prevState,\n  prev_phase: diffState.prevPhase,\n  new_state: phaseAndState.newState,\n  new_phase: phaseAndState.newPhase,\n  changed: diffState.changed,\n  high_events_count: candidates.highEvents.length,\n  active_events_count: candidates.activeEvents.length\n});\n\nif (!diffState.changed) {\n  return [];\n}\n\nreturn runStep('BuildOutputPayload', () => {\n  let context = null;\n  if (phaseAndState.primary) {\n    const e = phaseAndState.primary.event;\n    const minutesToEvent = e.eventMs > nowMs ? Math.max(0, Math.ceil((e.eventMs - nowMs) / 60000)) : 0;\n    context = {\n      event_name: e.title,\n      event_title: e.title,\n      event_time: new Date(e.eventMs).toISOString(),\n      minutes_to_event: minutesToEvent,\n      impact: e.impact,\n      phase: phaseAndState.newPhase,\n      currency: e.currency || e.country || 'N/A'\n    };\n  }\n\n  return [{\n    json: {\n      event_type: 'volatility.state_changed',\n      state: phaseAndState.newState,\n      phase: phaseAndState.newPhase,\n      state_changed: diffState.changed,\n      timestamp: nowUtc,\n      context\n    }\n  }];\n});"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          520,
          0
        ],
        "id": "9a7fe22b-2515-44ff-a0e0-6119e299f492",
        "name": "Compute Volatility State"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { \"event_type\": $json.event_type, \"state\": $json.state, \"phase\": $json.phase, \"timestamp\": $json.timestamp, \"context\": $json.context } }}",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          780,
          0
        ],
        "id": "480f5790-24d3-4d0d-8e45-2b6fb1dbc8c9",
        "name": "Send to Bridge"
      }
    ],
    "connections": {
      "Cron": {
        "main": [
          [
            {
              "node": "Fetch Calendar",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Calendar": {
        "main": [
          [
            {
              "node": "Compute Volatility State",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compute Volatility State": {
        "main": [
          [
            {
              "node": "Send to Bridge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    }
  }
]
