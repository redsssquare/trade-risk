[
  {
    "name": "Volatility Window",
    "active": false,
    "nodes": [
      {
        "parameters": {
          "triggerTimes": {
            "item": [
              {
                "mode": "everyX",
                "value": 1,
                "unit": "minutes"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.cron",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "0ec07dd3-57be-4bee-a778-46f0f23cdf11",
        "name": "Cron"
      },
      {
        "parameters": {
          "method": "GET",
          "url": "http://bridge:3000/calendar-feed",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          260,
          0
        ],
        "id": "11111111-2222-4333-8444-555555555555",
        "name": "Fetch Calendar"
      },
      {
        "parameters": {
          "jsCode": "const preWindowMs = 7 * 60 * 1000;\nconst duringWindowMs = 4 * 60 * 1000;\nconst postWindowMs = 9 * 60 * 1000;\n\nconst nowMs = Date.now();\nconst nowUtc = new Date(nowMs).toISOString();\nconst staticData = $getWorkflowStaticData('global');\n\nconst log = (payload) => {\n  console.log(JSON.stringify({ workflow: 'volatility-state-mvp-cache', ...payload }));\n};\n\nconst resolvePhase = (eventMs, ts) => {\n  if (eventMs - preWindowMs <= ts && ts < eventMs) return 'pre_event';\n  if (eventMs <= ts && ts < eventMs + duringWindowMs) return 'during_event';\n  if (eventMs + duringWindowMs <= ts && ts < eventMs + postWindowMs) return 'post_event';\n  return 'none';\n};\n\nconst inputItems = $input.all();\nconst first = inputItems.length > 0 ? inputItems[0].json : null;\nconst payload = first && Array.isArray(first.items) ? first.items : [];\n\nif (!Array.isArray(payload) || payload.length === 0) {\n  log({ now_utc: nowUtc, error: 'calendar_payload_empty', feed_source: first && first.source });\n  return [];\n}\n\nconst highEvents = payload\n  .filter((e) => e && e.impact === 'High' && typeof e.title === 'string' && typeof e.date === 'string')\n  .map((e) => {\n    const eventMs = Date.parse(e.date);\n    if (Number.isNaN(eventMs)) return null;\n    return { ...e, eventMs };\n  })\n  .filter(Boolean);\n\nconst activeEvents = highEvents\n  .map((e) => ({ event: e, phase: resolvePhase(e.eventMs, nowMs) }))\n  .filter((x) => x.phase !== 'none')\n  .sort((a, b) => Math.abs(a.event.eventMs - nowMs) - Math.abs(b.event.eventMs - nowMs));\n\nconst primary = activeEvents.length > 0 ? activeEvents[0] : null;\nconst newState = primary ? 'RED' : 'GREEN';\nconst newPhase = primary ? primary.phase : 'none';\n\nconst prevState = staticData.current_state ?? null;\nconst prevPhase = staticData.current_phase ?? null;\nconst firstRun = prevState === null;\nconst bootstrapKey = 'mvp_bootstrap_sent_v2';\nconst bootstrapSend = staticData[bootstrapKey] !== true;\nconst changed = firstRun || prevState !== newState || prevPhase !== newPhase || bootstrapSend;\n\nstaticData.current_state = newState;\nstaticData.current_phase = newPhase;\nstaticData[bootstrapKey] = true;\n\nlog({\n  now_utc: nowUtc,\n  feed_source: first && first.source,\n  prev_state: prevState,\n  prev_phase: prevPhase,\n  new_state: newState,\n  new_phase: newPhase,\n  changed,\n  high_events_count: highEvents.length,\n  active_events_count: activeEvents.length\n});\n\nif (!changed) {\n  return [];\n}\n\nlet context = null;\nif (primary) {\n  const e = primary.event;\n  const minutesToEvent = e.eventMs > nowMs ? Math.max(0, Math.ceil((e.eventMs - nowMs) / 60000)) : 0;\n  context = {\n    event_name: e.title,\n    event_title: e.title,\n    event_time: new Date(e.eventMs).toISOString(),\n    minutes_to_event: minutesToEvent,\n    impact: e.impact,\n    phase: newPhase,\n    currency: e.currency || e.country || 'N/A'\n  };\n}\n\nreturn [{\n  json: {\n    event_type: 'volatility.state_changed',\n    state: newState,\n    phase: newPhase,\n    state_changed: changed,\n    timestamp: nowUtc,\n    context\n  }\n}];"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          520,
          0
        ],
        "id": "9a7fe22b-2515-44ff-a0e0-6119e299f492",
        "name": "Compute Volatility State"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { \"event_type\": $json.event_type, \"state\": $json.state, \"phase\": $json.phase, \"timestamp\": $json.timestamp, \"context\": $json.context } }}",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          780,
          0
        ],
        "id": "480f5790-24d3-4d0d-8e45-2b6fb1dbc8c9",
        "name": "Send to Bridge"
      }
    ],
    "connections": {
      "Cron": {
        "main": [
          [
            {
              "node": "Fetch Calendar",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Calendar": {
        "main": [
          [
            {
              "node": "Compute Volatility State",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compute Volatility State": {
        "main": [
          [
            {
              "node": "Send to Bridge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    }
  }
]
