[
  {
    "name": "Volatility Window",
    "active": false,
    "nodes": [
      {
        "parameters": {
          "triggerTimes": {
            "item": [
              {
                "mode": "everyX",
                "value": 1,
                "unit": "minutes"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.cron",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "0ec07dd3-57be-4bee-a778-46f0f23cdf11",
        "name": "Cron"
      },
      {
        "parameters": {
          "method": "GET",
          "url": "http://bridge:3000/calendar-feed",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          260,
          0
        ],
        "id": "11111111-2222-4333-8444-555555555555",
        "name": "Fetch Calendar"
      },
      {
        "parameters": {
          "jsCode": "const preWindowMs = 7 * 60 * 1000;\nconst duringWindowMs = 4 * 60 * 1000;\nconst postWindowMs = 9 * 60 * 1000;\nconst clusterWindowMin = 5;\nconst clusterWindowMs = clusterWindowMin * 60 * 1000;\n\nconst nowMs = Date.now();\nconst nowUtc = new Date(nowMs).toISOString();\nconst staticData = $getWorkflowStaticData('global');\n\nconst log = (payload) => {\n  console.log(JSON.stringify({ workflow: 'volatility-state-mvp-cache', ...payload }));\n};\n\nconst resolveClusterPhase = (clusterStartMs, clusterEndMs, ts) => {\n  if (clusterStartMs - preWindowMs <= ts && ts < clusterStartMs) return 'pre_event';\n  if (clusterStartMs <= ts && ts < clusterEndMs + duringWindowMs) return 'during_event';\n  if (clusterEndMs + duringWindowMs <= ts && ts < clusterEndMs + postWindowMs) return 'post_event';\n  return 'none';\n};\n\nconst sortByNearestTime = (ts) => (a, b) => {\n  const distanceA = Math.abs(a.eventMs - ts);\n  const distanceB = Math.abs(b.eventMs - ts);\n  if (distanceA !== distanceB) return distanceA - distanceB;\n  return a.eventMs - b.eventMs;\n};\n\nconst buildEventClusters = (events) => {\n  const sorted = [...events].sort((a, b) => a.eventMs - b.eventMs);\n  const clusters = [];\n  for (const event of sorted) {\n    const prevCluster = clusters[clusters.length - 1];\n    if (!prevCluster) {\n      clusters.push({ events: [event], clusterStartMs: event.eventMs, clusterEndMs: event.eventMs });\n      continue;\n    }\n    const prevEvent = prevCluster.events[prevCluster.events.length - 1];\n    if (event.eventMs - prevEvent.eventMs <= clusterWindowMs) {\n      prevCluster.events.push(event);\n      prevCluster.clusterEndMs = event.eventMs;\n      continue;\n    }\n    clusters.push({ events: [event], clusterStartMs: event.eventMs, clusterEndMs: event.eventMs });\n  }\n  return clusters;\n};\n\nconst sortClustersByNearestEvent = (ts) => (a, b) => {\n  const nearestA = [...a.events].sort(sortByNearestTime(ts))[0];\n  const nearestB = [...b.events].sort(sortByNearestTime(ts))[0];\n  const distanceA = nearestA ? Math.abs(nearestA.eventMs - ts) : Number.MAX_SAFE_INTEGER;\n  const distanceB = nearestB ? Math.abs(nearestB.eventMs - ts) : Number.MAX_SAFE_INTEGER;\n  if (distanceA !== distanceB) return distanceA - distanceB;\n  return a.clusterStartMs - b.clusterStartMs;\n};\n\nconst runStep = (stepName, handler) => {\n  try {\n    return handler();\n  } catch (error) {\n    log({\n      now_utc: nowUtc,\n      error: 'compute_step_failed',\n      failed_block: stepName,\n      error_message: error && error.message ? error.message : String(error)\n    });\n    throw error;\n  }\n};\n\nconst normalizedInput = runStep('NormalizeInput', () => {\n  const inputItems = $input.all();\n  const first = inputItems.length > 0 ? inputItems[0].json : null;\n  const payload = first && Array.isArray(first.items) ? first.items : [];\n  return { first, payload };\n});\n\nif (!Array.isArray(normalizedInput.payload) || normalizedInput.payload.length === 0) {\n  log({\n    now_utc: nowUtc,\n    error: 'calendar_payload_empty',\n    failed_block: 'NormalizeInput',\n    feed_source: normalizedInput.first && normalizedInput.first.source\n  });\n  return [];\n}\n\nconst candidates = runStep('BuildActiveCandidates', () => {\n  const highEvents = normalizedInput.payload\n    .filter((e) => e && e.impact === 'High' && typeof e.title === 'string' && typeof e.date === 'string')\n    .map((e) => {\n      const eventMs = Date.parse(e.date);\n      if (Number.isNaN(eventMs)) return null;\n      return { ...e, eventMs };\n    })\n    .filter(Boolean);\n\n  const clusters = buildEventClusters(highEvents);\n  const activeClusters = clusters\n    .map((cluster) => ({\n      ...cluster,\n      phase: resolveClusterPhase(cluster.clusterStartMs, cluster.clusterEndMs, nowMs)\n    }))\n    .filter((cluster) => cluster.phase !== 'none')\n    .sort(sortClustersByNearestEvent(nowMs));\n\n  return { highEvents, clusters, activeClusters };\n});\n\nconst phaseAndState = runStep('ResolvePhaseAndState', () => {\n  const primaryCluster = candidates.activeClusters.length > 0 ? candidates.activeClusters[0] : null;\n  const primaryEvent = primaryCluster\n    ? [...primaryCluster.events].sort(sortByNearestTime(nowMs))[0]\n    : null;\n  const newState = primaryCluster ? 'RED' : 'GREEN';\n  const newPhase = primaryCluster ? primaryCluster.phase : 'none';\n  return { primaryCluster, primaryEvent, newState, newPhase };\n});\n\nconst diffState = runStep('DiffWithPreviousState', () => {\n  const prevState = staticData.current_state ?? null;\n  const prevPhase = staticData.current_phase ?? null;\n  const firstRun = prevState === null;\n  const bootstrapKey = 'mvp_bootstrap_sent_v2';\n  const bootstrapSend = staticData[bootstrapKey] !== true;\n  const changed = firstRun || prevState !== phaseAndState.newState || prevPhase !== phaseAndState.newPhase || bootstrapSend;\n\n  staticData.current_state = phaseAndState.newState;\n  staticData.current_phase = phaseAndState.newPhase;\n  staticData[bootstrapKey] = true;\n\n  return {\n    prevState,\n    prevPhase,\n    changed\n  };\n});\n\nlog({\n  now_utc: nowUtc,\n  feed_source: normalizedInput.first && normalizedInput.first.source,\n  prev_state: diffState.prevState,\n  prev_phase: diffState.prevPhase,\n  new_state: phaseAndState.newState,\n  new_phase: phaseAndState.newPhase,\n  changed: diffState.changed,\n  high_events_count: candidates.highEvents.length,\n  active_clusters_count: candidates.activeClusters.length\n});\n\nif (!diffState.changed) {\n  return [];\n}\n\nreturn runStep('BuildOutputPayload', () => {\n  let context = null;\n  if (phaseAndState.primaryCluster && phaseAndState.primaryEvent) {\n    const e = phaseAndState.primaryEvent;\n    const clusterEvents = phaseAndState.primaryCluster.events.map((event) => ({\n      name: event.title,\n      time: new Date(event.eventMs).toISOString(),\n      impact: event.impact\n    }));\n    const minutesToEvent = e.eventMs > nowMs ? Math.max(0, Math.ceil((e.eventMs - nowMs) / 60000)) : 0;\n    context = {\n      event_name: e.title,\n      event_title: e.title,\n      event_time: new Date(e.eventMs).toISOString(),\n      minutes_to_event: minutesToEvent,\n      impact: e.impact,\n      phase: phaseAndState.newPhase,\n      currency: e.currency || e.country || 'N/A',\n      cluster_size: clusterEvents.length,\n      cluster_events: clusterEvents,\n      cluster_window_min: clusterWindowMin\n    };\n  }\n\n  return [{\n    json: {\n      event_type: 'volatility.state_changed',\n      state: phaseAndState.newState,\n      phase: phaseAndState.newPhase,\n      state_changed: diffState.changed,\n      timestamp: nowUtc,\n      context\n    }\n  }];\n});"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          520,
          0
        ],
        "id": "9a7fe22b-2515-44ff-a0e0-6119e299f492",
        "name": "Compute Volatility State"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { \"event_type\": $json.event_type, \"state\": $json.state, \"phase\": $json.phase, \"timestamp\": $json.timestamp, \"context\": $json.context } }}",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          780,
          0
        ],
        "id": "480f5790-24d3-4d0d-8e45-2b6fb1dbc8c9",
        "name": "Send to Bridge"
      }
    ],
    "connections": {
      "Cron": {
        "main": [
          [
            {
              "node": "Fetch Calendar",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Calendar": {
        "main": [
          [
            {
              "node": "Compute Volatility State",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compute Volatility State": {
        "main": [
          [
            {
              "node": "Send to Bridge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    }
  }
]
