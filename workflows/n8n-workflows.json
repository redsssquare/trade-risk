[
  {
    "updatedAt": "2026-02-21T05:15:18.988Z",
    "createdAt": "2026-02-21T05:15:18.988Z",
    "id": "P7QCx8bF0AkJxWYG",
    "name": "My workflow",
    "description": null,
    "active": false,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {},
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "bd42b0ae-47a2-48ad-86e4-f165856a2b98",
        "name": "When clicking ‘Test workflow’"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          220,
          0
        ],
        "id": "72c1e2ef-7fce-4a2d-9f59-a075293c39bb",
        "name": "HTTP Request"
      }
    ],
    "connections": {
      "When clicking ‘Test workflow’": {
        "main": [
          [
            {
              "node": "HTTP Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    },
    "staticData": null,
    "meta": null,
    "pinData": {},
    "versionId": "ed42063f-1990-4032-8fc9-4956d96bc0ec",
    "activeVersionId": null,
    "versionCounter": 1,
    "triggerCount": 0,
    "tags": [],
    "shared": [
      {
        "updatedAt": "2026-02-21T05:15:19.000Z",
        "createdAt": "2026-02-21T05:15:19.000Z",
        "role": "workflow:owner",
        "workflowId": "P7QCx8bF0AkJxWYG",
        "projectId": "oBUZlnjRkJSisNDR",
        "project": {
          "updatedAt": "2026-02-21T05:13:27.659Z",
          "createdAt": "2026-02-21T05:09:06.451Z",
          "id": "oBUZlnjRkJSisNDR",
          "name": "Artur Yurin <redsssquare@gmail.com>",
          "type": "personal",
          "icon": null,
          "description": null,
          "creatorId": "9e1b4998-f5ec-4021-97d8-7e8caf68661f"
        }
      }
    ]
  },
  {
    "updatedAt": "2026-02-21T06:42:05.000Z",
    "createdAt": "2026-02-21T06:41:29.803Z",
    "id": "2obNJ6LPFN0BWzAA",
    "name": "Phase B Webhook to Bridge",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "phase-b-webhook",
          "responseMode": "onReceived",
          "options": {}
        },
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 2.1,
        "position": [
          0,
          0
        ],
        "id": "79c88222-4dca-4d58-a8f8-c2457804ac18",
        "name": "Webhook"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "{\"source\":\"n8n\",\"event\":\"phase-b\",\"value\":1}",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          260,
          0
        ],
        "id": "9f6ab314-f4a7-4fbb-b145-0ea560921a77",
        "name": "HTTP Request"
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "HTTP Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "eeffbb00-9dea-49f1-9812-50c32ae732a0",
    "activeVersionId": "eeffbb00-9dea-49f1-9812-50c32ae732a0",
    "versionCounter": 4,
    "triggerCount": 1,
    "tags": [],
    "shared": [
      {
        "updatedAt": "2026-02-21T06:41:29.809Z",
        "createdAt": "2026-02-21T06:41:29.809Z",
        "role": "workflow:owner",
        "workflowId": "2obNJ6LPFN0BWzAA",
        "projectId": "oBUZlnjRkJSisNDR",
        "project": {
          "updatedAt": "2026-02-21T05:13:27.659Z",
          "createdAt": "2026-02-21T05:09:06.451Z",
          "id": "oBUZlnjRkJSisNDR",
          "name": "Artur Yurin <redsssquare@gmail.com>",
          "type": "personal",
          "icon": null,
          "description": null,
          "creatorId": "9e1b4998-f5ec-4021-97d8-7e8caf68661f"
        }
      }
    ]
  },
  {
    "updatedAt": "2026-02-21T06:49:37.000Z",
    "createdAt": "2026-02-21T06:46:19.483Z",
    "id": "5RMOWxH5z6OxGXHk",
    "name": "Phase B Webhook to Bridge UI",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "httpMethod": "POST",
          "path": "phase-b-ui",
          "responseMode": "lastNode",
          "options": {}
        },
        "id": "webhook-node",
        "name": "Webhook",
        "type": "n8n-nodes-base.webhook",
        "typeVersion": 1,
        "position": [
          250,
          300
        ],
        "webhookId": "phase-b-ui"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "sendBody": true,
          "bodyParameters": {
            "parameters": [
              {
                "name": "source",
                "value": "n8n"
              },
              {
                "name": "event",
                "value": "phase-b"
              },
              {
                "name": "value",
                "value": 1
              }
            ]
          },
          "options": {}
        },
        "id": "http-request-node",
        "name": "HTTP Request",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          450,
          300
        ]
      }
    ],
    "connections": {
      "Webhook": {
        "main": [
          [
            {
              "node": "HTTP Request",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    },
    "staticData": null,
    "meta": null,
    "pinData": null,
    "versionId": "a2f8cf82-42d3-47d4-8a69-95b11377a25f",
    "activeVersionId": "a2f8cf82-42d3-47d4-8a69-95b11377a25f",
    "versionCounter": 4,
    "triggerCount": 1,
    "tags": [],
    "shared": [
      {
        "updatedAt": "2026-02-21T06:46:19.486Z",
        "createdAt": "2026-02-21T06:46:19.486Z",
        "role": "workflow:owner",
        "workflowId": "5RMOWxH5z6OxGXHk",
        "projectId": "oBUZlnjRkJSisNDR",
        "project": {
          "updatedAt": "2026-02-21T05:13:27.659Z",
          "createdAt": "2026-02-21T05:09:06.451Z",
          "id": "oBUZlnjRkJSisNDR",
          "name": "Artur Yurin <redsssquare@gmail.com>",
          "type": "personal",
          "icon": null,
          "description": null,
          "creatorId": "9e1b4998-f5ec-4021-97d8-7e8caf68661f"
        }
      }
    ]
  },
  {
    "updatedAt": "2026-02-21T07:45:31.143Z",
    "createdAt": "2026-02-21T07:29:16.770Z",
    "id": "FWLInwCQoPEoRPUR",
    "name": "Volatility State from Forex Factory",
    "description": null,
    "active": true,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {
          "triggerTimes": {
            "item": [
              {
                "mode": "everyX",
                "value": 1,
                "unit": "minutes"
              }
            ]
          }
        },
        "type": "n8n-nodes-base.cron",
        "typeVersion": 1,
        "position": [
          0,
          0
        ],
        "id": "0ec07dd3-57be-4bee-a778-46f0f23cdf11",
        "name": "Cron"
      },
      {
        "parameters": {
          "jsCode": "const preWindowMs = 30 * 60 * 1000;\nconst duringWindowMs = 5 * 60 * 1000;\nconst postWindowMs = 15 * 60 * 1000;\nconst timeoutMs = 10 * 1000;\nconst url = 'https://nfs.faireconomy.media/ff_calendar_thisweek.json';\nconst anchorAliases = [\n  'fomc',\n  'fed rate',\n  'interest rate decision',\n  'cpi',\n  'consumer price index',\n  'non-farm payrolls',\n  'nfp'\n];\n\nconst nowMs = Date.now();\nconst nowUtc = new Date(nowMs).toISOString();\n\nconst staticData = $getWorkflowStaticData('global');\nconst currentState = staticData.current_state || 'GREEN';\nconst currentPhase = staticData.current_phase || 'none';\n\nconst log = (payload) => {\n  console.log(JSON.stringify({\n    workflow: 'volatility-state',\n    ...payload\n  }));\n};\n\nconst isValidEvent = (event) => {\n  return Boolean(\n    event &&\n    typeof event === 'object' &&\n    typeof event.date === 'string' &&\n    typeof event.impact === 'string' &&\n    typeof event.title === 'string'\n  );\n};\n\nconst normalizeText = (value) => String(value || '').toLowerCase().trim();\n\nconst isAnchorHighEvent = (title) => {\n  const normalizedTitle = normalizeText(title);\n  if (!normalizedTitle) {\n    return false;\n  }\n\n  return anchorAliases.some((alias) => normalizedTitle.includes(alias));\n};\n\nconst resolvePhase = (eventMs) => {\n  if (eventMs - preWindowMs <= nowMs && nowMs < eventMs) {\n    return 'pre_event';\n  }\n\n  if (eventMs <= nowMs && nowMs < eventMs + duringWindowMs) {\n    return 'during_event';\n  }\n\n  if (eventMs + duringWindowMs <= nowMs && nowMs < eventMs + postWindowMs) {\n    return 'post_event';\n  }\n\n  return null;\n};\n\nconst sortByNearestTime = (a, b) => {\n  const distanceA = Math.abs(a.eventMs - nowMs);\n  const distanceB = Math.abs(b.eventMs - nowMs);\n  if (distanceA !== distanceB) {\n    return distanceA - distanceB;\n  }\n\n  return a.eventMs - b.eventMs;\n};\n\ntry {\n  const controller = new AbortController();\n  const timer = setTimeout(() => controller.abort(), timeoutMs);\n\n  let response;\n  try {\n    response = await fetch(url, {\n      method: 'GET',\n      signal: controller.signal,\n      headers: {\n        Accept: 'application/json'\n      }\n    });\n  } finally {\n    clearTimeout(timer);\n  }\n\n  if (!response.ok) {\n    log({\n      cron_tick_timestamp: nowUtc,\n      state: currentState,\n      phase: currentPhase,\n      llm_called: false,\n      primary_event: null,\n      contextual_anchor: false,\n      contextual_anchor_names: [],\n      error: `http_status_${response.status}`\n    });\n    return [];\n  }\n\n  let payload;\n  try {\n    payload = await response.json();\n  } catch (error) {\n    log({\n      cron_tick_timestamp: nowUtc,\n      state: currentState,\n      phase: currentPhase,\n      llm_called: false,\n      primary_event: null,\n      contextual_anchor: false,\n      contextual_anchor_names: [],\n      error: `invalid_json_parse:${error.message}`\n    });\n    return [];\n  }\n\n  if (!Array.isArray(payload)) {\n    log({\n      cron_tick_timestamp: nowUtc,\n      state: currentState,\n      phase: currentPhase,\n      llm_called: false,\n      primary_event: null,\n      contextual_anchor: false,\n      contextual_anchor_names: [],\n      error: 'invalid_json_shape:not_array'\n    });\n    return [];\n  }\n\n  const invalidItemIndex = payload.findIndex((event) => !isValidEvent(event));\n  if (invalidItemIndex !== -1) {\n    log({\n      cron_tick_timestamp: nowUtc,\n      state: currentState,\n      phase: currentPhase,\n      llm_called: false,\n      primary_event: null,\n      contextual_anchor: false,\n      contextual_anchor_names: [],\n      error: `invalid_json_shape:item_${invalidItemIndex}`\n    });\n    return [];\n  }\n\n  const highEvents = payload\n    .filter((event) => event.impact === 'High')\n    .map((event) => {\n      const eventMs = Date.parse(event.date);\n      if (Number.isNaN(eventMs)) {\n        return null;\n      }\n\n      return {\n        ...event,\n        eventMs,\n        is_anchor_high: isAnchorHighEvent(event.title)\n      };\n    })\n    .filter(Boolean);\n\n  const primaryEvent = highEvents.length > 0\n    ? [...highEvents].sort(sortByNearestTime)[0]\n    : null;\n\n  const primaryPhase = primaryEvent ? resolvePhase(primaryEvent.eventMs) : null;\n  const windowStartMs = primaryEvent ? primaryEvent.eventMs - preWindowMs : null;\n  const windowEndMs = primaryEvent ? primaryEvent.eventMs + postWindowMs : null;\n  const sameWindowHighEvents = primaryEvent\n    ? highEvents.filter((event) => windowStartMs <= event.eventMs && event.eventMs < windowEndMs)\n    : [];\n  const contextualAnchorEvents = primaryEvent && !primaryEvent.is_anchor_high\n    ? sameWindowHighEvents.filter((event) => event !== primaryEvent && event.is_anchor_high)\n    : [];\n  const contextualAnchorNames = Array.from(new Set(contextualAnchorEvents.map((event) => event.title)));\n  const contextualAnchor = contextualAnchorNames.length > 0;\n\n  const newState = primaryPhase ? 'RED' : 'GREEN';\n  const phase = primaryPhase || 'none';\n  let context = null;\n\n  if (newState === 'RED' && primaryEvent) {\n    const minutesToEvent = primaryEvent.eventMs > nowMs\n      ? Math.max(0, Math.ceil((primaryEvent.eventMs - nowMs) / 60000))\n      : 0;\n\n    context = {\n      event_name: primaryEvent.title,\n      event_title: primaryEvent.title,\n      currency: primaryEvent.currency || primaryEvent.country || 'N/A',\n      event_time: new Date(primaryEvent.eventMs).toISOString(),\n      minutes_to_event: minutesToEvent,\n      impact: primaryEvent.impact || 'High',\n      impact_type: primaryEvent.is_anchor_high ? 'anchor_high' : 'high',\n      phase,\n      contextual_anchor: primaryEvent.is_anchor_high ? false : contextualAnchor,\n      contextual_anchor_names: primaryEvent.is_anchor_high ? [] : contextualAnchorNames,\n      primary_event: {\n        name: primaryEvent.title,\n        time: new Date(primaryEvent.eventMs).toISOString()\n      }\n    };\n  }\n\n  const stateChanged = newState !== currentState;\n  const phaseChanged = phase !== currentPhase;\n  const notify = stateChanged || phaseChanged;\n\n  log({\n    cron_tick_timestamp: nowUtc,\n    state: newState,\n    phase,\n    llm_called: notify,\n    primary_event: primaryEvent\n      ? {\n          name: primaryEvent.title,\n          time: new Date(primaryEvent.eventMs).toISOString()\n        }\n      : null,\n    contextual_anchor: primaryEvent && !primaryEvent.is_anchor_high ? contextualAnchor : false,\n    contextual_anchor_names: primaryEvent && !primaryEvent.is_anchor_high ? contextualAnchorNames : [],\n    high_events_count: highEvents.length,\n    current_state: currentState,\n    current_phase: currentPhase,\n    state_changed: stateChanged,\n    phase_changed: phaseChanged\n  });\n\n  if (!notify) {\n    return [];\n  }\n\n  staticData.current_state = newState;\n  staticData.current_phase = phase;\n\n  return [\n    {\n      json: {\n        event_type: 'volatility.state_changed',\n        state: newState,\n        phase,\n        timestamp: nowUtc,\n        context\n      }\n    }\n  ];\n} catch (error) {\n  const errorText = error && error.name === 'AbortError'\n    ? `timeout_${timeoutMs}ms`\n    : `request_failed:${error.message}`;\n\n  log({\n    cron_tick_timestamp: nowUtc,\n    state: currentState,\n    phase: currentPhase,\n    llm_called: false,\n    primary_event: null,\n    contextual_anchor: false,\n    contextual_anchor_names: [],\n    error: errorText\n  });\n\n  return [];\n}"
        },
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          260,
          0
        ],
        "id": "9a7fe22b-2515-44ff-a0e0-6119e299f492",
        "name": "Compute Volatility State"
      },
      {
        "parameters": {
          "method": "POST",
          "url": "http://bridge:3000/hooks/event",
          "sendBody": true,
          "specifyBody": "json",
          "jsonBody": "={{ { \"event_type\": $json.event_type, \"state\": $json.state, \"phase\": $json.phase, \"timestamp\": $json.timestamp, \"context\": $json.context } }}",
          "options": {}
        },
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.2,
        "position": [
          520,
          0
        ],
        "id": "480f5790-24d3-4d0d-8e45-2b6fb1dbc8c9",
        "name": "Send to Bridge"
      }
    ],
    "connections": {
      "Cron": {
        "main": [
          [
            {
              "node": "Compute Volatility State",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Compute Volatility State": {
        "main": [
          [
            {
              "node": "Send to Bridge",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1",
      "callerPolicy": "workflowsFromSameOwner",
      "availableInMCP": false
    },
    "staticData": {
      "global": {}
    },
    "meta": null,
    "pinData": null,
    "versionId": "737e87a8-858a-433a-b8d9-5cfa9681f49c",
    "activeVersionId": "737e87a8-858a-433a-b8d9-5cfa9681f49c",
    "versionCounter": 7,
    "triggerCount": 1,
    "tags": [],
    "shared": [
      {
        "updatedAt": "2026-02-21T07:29:16.778Z",
        "createdAt": "2026-02-21T07:29:16.778Z",
        "role": "workflow:owner",
        "workflowId": "FWLInwCQoPEoRPUR",
        "projectId": "oBUZlnjRkJSisNDR",
        "project": {
          "updatedAt": "2026-02-21T05:13:27.659Z",
          "createdAt": "2026-02-21T05:09:06.451Z",
          "id": "oBUZlnjRkJSisNDR",
          "name": "Artur Yurin <redsssquare@gmail.com>",
          "type": "personal",
          "icon": null,
          "description": null,
          "creatorId": "9e1b4998-f5ec-4021-97d8-7e8caf68661f"
        }
      }
    ]
  }
]
