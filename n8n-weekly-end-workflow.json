[{"name":"Weekly End","active":false,"nodes":[{"parameters":{"triggerTimes":{"item":[{"mode":"everyWeek","weekday":5,"hour":17,"minute":30}]}},"type":"n8n-nodes-base.cron","typeVersion":1,"position":[0,0],"id":"weekly-end-cron-001","name":"Cron"},{"parameters":{"jsCode":"// Публикация только в пятницу с 20:00 до 21:00 МСК (фактически один запуск в 20:30 по крону).\nconst MOSCOW_OFFSET_MS = 3 * 60 * 60 * 1000;\nconst moscowDate = new Date(Date.now() + MOSCOW_OFFSET_MS);\nconst day = moscowDate.getUTCDay();\nconst hour = moscowDate.getUTCHours();\nif (day !== 5) return [];\nif (hour !== 20) return [];\nreturn [{ json: {} }];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[140,0],"id":"weekly-end-friday-gate","name":"Friday Gate"},{"parameters":{"method":"GET","url":"http://bridge:3000/calendar-feed","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[280,0],"id":"weekly-end-fetch-calendar","name":"Fetch Calendar"},{"parameters":{"jsCode":"// Агрегация по прошедшей неделе (пн 00:00 – пт 23:59 МСК), спек контракта weekly-digest.\nconst PRE_MS = 15 * 60 * 1000;\nconst POST_MS = 15 * 60 * 1000;\nconst DURING_MS = 5 * 60 * 1000;\nconst CLUSTER_WINDOW_MS = 5 * 60 * 1000;\nconst ANCHOR_ALIASES = /\\b(fomc|nfp|nonfarm|non-farm|cpi\\b|pce|fed\\s+rate|ecb\\s+rate|boe|bank\\s+of\\s+england|interest\\s+rate\\s+decision|ism\\s+manufacturing|ism\\s+services)\\b/i;\nconst DAY_NAMES = ['Mon','Tue','Wed','Thu','Fri'];\n\nfunction isAnchor(title) {\n  return typeof title === 'string' && ANCHOR_ALIASES.test(title);\n}\n\nfunction getMoscowWeekBounds() {\n  const MSK_OFFSET_MS = 3 * 60 * 60 * 1000;\n  const moscowNow = new Date(Date.now() + MSK_OFFSET_MS);\n  const y = moscowNow.getUTCFullYear();\n  const m = String(moscowNow.getUTCMonth() + 1).padStart(2, '0');\n  const d = String(moscowNow.getUTCDate()).padStart(2, '0');\n  const moscowDateStr = `${y}-${m}-${d}`;\n  const tempDate = new Date(moscowDateStr + 'T12:00:00+03:00');\n  const dayOfWeek = tempDate.getUTCDay();\n  const daysToMonday = (dayOfWeek + 6) % 7;\n  const mondayDate = new Date(tempDate);\n  mondayDate.setUTCDate(mondayDate.getUTCDate() - daysToMonday);\n  const mondayStr = mondayDate.toISOString().slice(0, 10);\n  const fridayDate = new Date(mondayDate);\n  fridayDate.setUTCDate(fridayDate.getUTCDate() + 4);\n  const fridayStr = fridayDate.toISOString().slice(0, 10);\n  const weekStartMs = new Date(mondayStr + 'T00:00:00+03:00').getTime();\n  const weekEndMs = new Date(fridayStr + 'T23:59:59.999+03:00').getTime();\n  return { weekStartMs, weekEndMs, mondayStr, fridayStr };\n}\n\n// Проверка: событие попадает в рабочие часы МСК (09:00–21:00) пн–пт.\nfunction isInMoscowWorkingHours(eventMs) {\n  const MSK_OFFSET_MS = 3 * 60 * 60 * 1000;\n  const mskDate = new Date(eventMs + MSK_OFFSET_MS);\n  const dayOfWeek = mskDate.getUTCDay(); // 0=вс, 1=пн, ..., 5=пт, 6=сб\n  if (dayOfWeek === 0 || dayOfWeek === 6) return false;\n  const hour = mskDate.getUTCHours();\n  const minute = mskDate.getUTCMinutes();\n  const timeMinutes = hour * 60 + minute;\n  return timeMinutes >= 9 * 60 && timeMinutes < 21 * 60;\n}\n\nfunction buildEventClusters(events) {\n  const sorted = [...events].sort((a, b) => a.eventMs - b.eventMs);\n  const clusters = [];\n  for (const event of sorted) {\n    const prev = clusters[clusters.length - 1];\n    if (!prev || event.eventMs - prev.clusterEndMs > CLUSTER_WINDOW_MS) {\n      clusters.push({ events: [event], clusterStartMs: event.eventMs, clusterEndMs: event.eventMs });\n    } else {\n      prev.events.push(event);\n      prev.clusterEndMs = event.eventMs;\n    }\n  }\n  return clusters;\n}\n\nfunction mergeIntervals(intervals) {\n  if (intervals.length === 0) return [];\n  const sorted = [...intervals].sort((a, b) => a.start - b.start);\n  const merged = [{ start: sorted[0].start, end: sorted[0].end }];\n  for (let i = 1; i < sorted.length; i++) {\n    const last = merged[merged.length - 1];\n    if (sorted[i].start <= last.end) {\n      last.end = Math.max(last.end, sorted[i].end);\n    } else {\n      merged.push({ start: sorted[i].start, end: sorted[i].end });\n    }\n  }\n  return merged;\n}\n\nconst inputItems = $input.all();\nconst first = inputItems.length > 0 ? inputItems[0].json : null;\nconst rawItems = first && Array.isArray(first.items) ? first.items : [];\n\nconst { weekStartMs, weekEndMs, mondayStr, fridayStr } = getMoscowWeekBounds();\nconst week_range = `${mondayStr.slice(8, 10)}–${fridayStr.slice(8, 10)}.${fridayStr.slice(5, 7)}`;\n\nconst weekItems = rawItems\n  .filter((e) => e && typeof e.title === 'string' && typeof e.date === 'string')\n  .map((e) => {\n    const eventMs = Date.parse(e.date);\n    if (!Number.isFinite(eventMs) || eventMs < weekStartMs || eventMs > weekEndMs) return null;\n    if (!isInMoscowWorkingHours(eventMs)) return null;\n    return { ...e, eventMs };\n  })\n  .filter(Boolean);\n\nconst highEvents = weekItems.filter((e) => String(e.impact || '').toLowerCase() === 'high');\nconst high_events = highEvents.length;\nconst anchor_events = highEvents.filter((e) => isAnchor(e.title || '')).length;\nconst clusters = buildEventClusters(highEvents);\nconst clusterCount = clusters.filter((c) => c.events.length >= 2).length;\n\nconst intervals = clusters.map((c) => ({\n  start: c.clusterStartMs - PRE_MS,\n  end: c.clusterEndMs + DURING_MS + POST_MS\n}));\nconst merged = mergeIntervals(intervals);\nconst total_window_minutes = Math.round(merged.reduce((sum, r) => sum + (r.end - r.start) / 60000, 0));\n\nconst daySet = new Set();\nhighEvents.forEach((e) => {\n  const dayIndex = Math.floor((e.eventMs - weekStartMs) / (24 * 60 * 60 * 1000));\n  if (dayIndex >= 0 && dayIndex <= 4) daySet.add(dayIndex);\n});\nconst active_days = [...daySet].sort((a, b) => a - b).map((i) => DAY_NAMES[i]);\nconst quiet_days_count = 5 - active_days.length;\n\nconst eventsPerDay = [0, 0, 0, 0, 0];\nhighEvents.forEach((e) => {\n  const dayIndex = Math.floor((e.eventMs - weekStartMs) / (24 * 60 * 60 * 1000));\n  if (dayIndex >= 0 && dayIndex <= 4) eventsPerDay[dayIndex]++;\n});\nconst busy_day_bonus = eventsPerDay.some((c) => c >= 3) ? 1 : 0;\n\nconst payload = {\n  week_range,\n  high_events,\n  anchor_events,\n  clusters: clusterCount,\n  total_window_minutes,\n  active_days,\n  quiet_days_count,\n  busy_day_bonus\n};\n\nreturn [{ json: payload }];"},"type":"n8n-nodes-base.code","typeVersion":2,"position":[520,0],"id":"weekly-end-aggregate","name":"Weekly Aggregate"},{"parameters":{"method":"POST","url":"http://bridge:3000/weekly-digest","sendBody":true,"specifyBody":"json","jsonBody":"={{ $json }}","options":{}},"type":"n8n-nodes-base.httpRequest","typeVersion":4.2,"position":[760,0],"id":"weekly-end-post-bridge","name":"POST Weekly Digest"}],"connections":{"Cron":{"main":[[{"node":"Friday Gate","type":"main","index":0}]]},"Friday Gate":{"main":[[{"node":"Fetch Calendar","type":"main","index":0}]]},"Fetch Calendar":{"main":[[{"node":"Weekly Aggregate","type":"main","index":0}]]},"Weekly Aggregate":{"main":[[{"node":"POST Weekly Digest","type":"main","index":0}]]}},"settings":{"executionOrder":"v1"}}]
